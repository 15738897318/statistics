<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Statistics: kmeans</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css" integrity="sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-U1DAWAznBHeqEIlVSCgzq+c9gqGAJn5c/t99JyeKa9xxaYpSvHU5awsuZVVFIhvj" crossorigin="anonymous"></script>
    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
    </script>
    <style>
    var {
      font-style: italics;
      font-weight: bold;
    }
    td {
      vertical-align: top;
    }
    </style>
  </head>
  <body>
    <div class="bg-dark">
      <div class="container-xl">
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
          <div class="container-fluid">
            <a class="navbar-brand" href=index.html>
              <img src="assets/statistics.png" alt="statistics" class="d-inline-block align-top" width="25" height="25">
              Statistics
            </a>
            <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
              <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
              <ul class="navbar-nav">
                <li class="nav-item">
                  <a class="nav-link" href="index.html#Clustering">
                    <i class="fas fa-list-alt"></i>
                    Clustering
                  </a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="https://gnu-octave.github.io/packages/">
                  <img src="assets/octave-logo.svg" alt="GNU Octave logo" class="d-inline-block align-top" width="25" height="25">
                    Octave Packages
                  </a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="https://www.octave.org">
                    <i class="fas fa-home"></i>
                    GNU Octave website
                  </a>
                </li>
              </ul>
            </div>
          </div>
        </nav>
      </div>
    </div>
    <div class="container-xl my-4">
      <div class="card rounded">
        <div class="card-header card-header-mod">
          <div class="row d-flex flex-wrap align-items-center">
            <div class="col-sm-3 col-md-5 mb-2 mb-sm-0">
              <h3 class="d-inline-block mr-2">
              Function&nbsp;Reference: <b><code>kmeans</code></b>
              </h3>
            </div>
          </div>
        </div>
        <div class="card-body">
<dl>
<dt><u>statistics:</u> <var>idx</var> = <b>kmeans</b><i> (<var>data</var>, <var>k</var>)</i></dt>
<dt><u>statistics:</u> [<var>idx</var>, <var>centers</var>] = <b>kmeans</b><i> (<var>data</var>, <var>k</var>)</i></dt>
<dt><u>statistics:</u> [<var>idx</var>, <var>centers</var>, <var>sumd</var>] = <b>kmeans</b><i> (<var>data</var>, <var>k</var>)</i></dt>
<dt><u>statistics:</u> [<var>idx</var>, <var>centers</var>, <var>sumd</var>, <var>dist</var>] = <b>kmeans</b><i> (<var>data</var>, <var>k</var>)</i></dt>
<dt><u>statistics:</u> [&hellip;] = <b>kmeans</b><i> (<var>data</var>, <var>k</var>, <var>param1</var>, <var>value1</var>, &hellip;)</i></dt>
<dt><u>statistics:</u> [&hellip;] = <b>kmeans</b><i> (<var>data</var>, [], <code>&quot;start&quot;</code>, <var>start</var>, &hellip;)</i></dt>
</dl>

<p> Perform a <var>k</var>-means clustering of the <math>N&times;D</math> matrix <var>data</var>.
</p>
<div class="ms-5">
<p> If parameter <code>&quot;start&quot;</code> is specified, then <var>k</var> may be empty
 in which case <var>k</var> is set to the number of rows of <var>start</var>.
</p>
<p> The outputs are:
</p>
 <table>
<tr><td width="15%"><var>idx</var></td><td width="5%"></td><td width="80%">An <math>N&times;1</math> vector whose <math>i</math>-th element is
 the class to which row <math>i</math> of <var>data</var> is assigned.</td></tr>
<tr><td width="15%"><var>centers</var></td><td width="5%"></td><td width="80%">A <math>K&times;D</math> array whose <math>i</math>-th row is the
 centroid of cluster <math>i</math>.</td></tr>
<tr><td width="15%"><var>sumd</var></td><td width="5%"></td><td width="80%">A <math>k&times;1</math> vector whose <math>i</math>-th entry is the
 sum of the distances from samples in cluster <math>i</math> to centroid <math>i</math>.</td></tr>
<tr><td width="15%"><var>dist</var></td><td width="5%"></td><td width="80%">An <math>N&times;k</math> matrix whose <math>i</math><math>j</math>-th
 element is the distance from sample <math>i</math> to centroid <math>j</math>.</td></tr>
</table>

<p> The following parameters may be placed in any order.  Each parameter
 must be followed by its value, as in Name-Value pairs.
</p>
 <table>
<thead><tr><th width="15%">Name</th><th width="2%"></th><th width="83%">Description</th></tr></thead>
<tr><td width="15%"><code>&quot;Start&quot;</code></td><td width="2%"></td><td width="83%">The initialization method for the centroids.</td></tr>
</table>

 <table>
<thead><tr><th width="4%"></th><th width="19%">Value</th><th width="2%"></th><th width="75%">Description</th></tr></thead>
<tr><td width="4%"></td><td width="19%"><code>&quot;plus&quot;</code></td><td width="2%"></td><td width="75%">The k-means++ algorithm.  (Default)</td></tr>
<tr><td width="4%"></td><td width="19%"><code>&quot;sample&quot;</code></td><td width="2%"></td><td width="75%">A subset of <math>k</math> rows from
 <var>data</var>, sampled uniformly without replacement.</td></tr>
<tr><td width="4%"></td><td width="19%"><code>&quot;cluster&quot;</code></td><td width="2%"></td><td width="75%">Perform a pilot clustering on 10% of
 the rows of <var>data</var>.</td></tr>
<tr><td width="4%"></td><td width="19%"><code>&quot;uniform&quot;</code></td><td width="2%"></td><td width="75%">Each component of each centroid is
 drawn uniformly from the interval between the maximum and minimum values of
 that component within <var>data</var>.  This performs poorly and is implemented
 only for Matlab compatibility.</td></tr>
<tr><td width="4%"></td><td width="19%"><var>numeric matrix</var></td><td width="2%"></td><td width="75%">A <math>k&times;D</math> matrix of centroid
 starting locations.  The rows correspond to seeds.</td></tr>
<tr><td width="4%"></td><td width="19%"><var>numeric array</var></td><td width="2%"></td><td width="75%">A <math>k&times;D&times;r</math> array of centroid
 starting locations.  The third dimension invokes replication of the
 clustering routine.  Page <math>r</math> contains the set of seeds for replicate
 <math>r</math>.  <code>kmeans</code> infers the number of replicates (specified by the
 <code>&quot;Replicates&quot;</code> Name-Value pair argument) from the size of the third
 dimension.</td></tr>
</table>

 <table>
<thead><tr><th width="15%">Name</th><th width="2%"></th><th width="83%">Description</th></tr></thead>
<tr><td width="15%"><code>&quot;Distance&quot;</code></td><td width="2%"></td><td width="83%">The distance measure used for partitioning
 and calculating centroids.</td></tr>
</table>

 <table>
<thead><tr><th width="4%"></th><th width="19%">Value</th><th width="2%"></th><th width="75%">Description</th></tr></thead>
<tr><td width="4%"></td><td width="19%"><code>&quot;sqeuclidean&quot;</code></td><td width="2%"></td><td width="75%">The squared Euclidean distance.
 i.e. the sum of the squares of the differences between corresponding
 components.  In this case, the centroid is the arithmetic mean of all samples
 in its cluster.  This is the only distance for which this algorithm is truly
 &quot;k-means&quot;.</td></tr>
<tr><td width="4%"></td><td width="19%"><code>&quot;cityblock&quot;</code></td><td width="2%"></td><td width="75%">The sum metric, or L1 distance,
 i.e. the sum of the absolute differences between corresponding components.
 In this case, the centroid is the median of all samples in its cluster.
 This gives the k-medians algorithm.</td></tr>
<tr><td width="4%"></td><td width="19%"><code>&quot;cosine&quot;</code></td><td width="2%"></td><td width="75%">One minus the cosine of the included
 angle between points (treated as vectors). Each centroid is the mean of the
 points in that cluster, after normalizing those points to unit Euclidean
 length.</td></tr>
<tr><td width="4%"></td><td width="19%"><code>&quot;correlation&quot;</code></td><td width="2%"></td><td width="75%">One minus the sample correlation
 between points (treated as sequences of values).  Each centroid is the
 component-wise mean of the points in that cluster, after centering and
 normalizing those points to zero mean and unit standard deviation.</td></tr>
<tr><td width="4%"></td><td width="19%"><code>&quot;hamming&quot;</code></td><td width="2%"></td><td width="75%">The number of components in which the
 sample and the centroid differ.  In this case, the centroid is the median of
 all samples in its cluster.  Unlike Matlab, Octave allows non-logical
 <var>data</var>.</td></tr>
</table>

 <table>
<thead><tr><th width="15%">Name</th><th width="2%"></th><th width="83%">Description</th></tr></thead>
<tr><td width="15%"><code>&quot;EmptyAction&quot;</code></td><td width="2%"></td><td width="83%">What to do when a centroid is not the
 closest to any data sample.</td></tr>
</table>

 <table>
<thead><tr><th width="4%"></th><th width="19%">Value</th><th width="2%"></th><th width="75%">Description</th></tr></thead>
<tr><td width="4%"></td><td width="19%"><code>&quot;error&quot;</code></td><td width="2%"></td><td width="75%">Throw an error.</td></tr>
<tr><td width="4%"></td><td width="19%"><code>&quot;singleton&quot;</code></td><td width="2%"></td><td width="75%">(Default) Select the row of
 <var>data</var> that has the highest error and use that as the new centroid.</td></tr>
<tr><td width="4%"></td><td width="19%"><code>&quot;drop&quot;</code></td><td width="2%"></td><td width="75%">Remove the centroid, and continue
 computation with one fewer centroid.  The dimensions of the outputs
 <var>centroids</var> and <var>d</var> are unchanged, with values for omitted centroids
 replaced by NaN.</td></tr>
</table>

 <table>
<thead><tr><th width="15%">Name</th><th width="2%"></th><th width="83%">Description</th></tr></thead>
<tr><td width="15%"><code>&quot;Display&quot;</code></td><td width="2%"></td><td width="83%">Display a text summary.</td></tr>
</table>

 <table>
<thead><tr><th width="4%"></th><th width="19%">Value</th><th width="2%"></th><th width="75%">Description</th></tr></thead>
<tr><td width="4%"></td><td width="19%"><code>&quot;off&quot;</code></td><td width="2%"></td><td width="75%">(Default) Display no summary.</td></tr>
<tr><td width="4%"></td><td width="19%"><code>&quot;final&quot;</code></td><td width="2%"></td><td width="75%">Display a summary for each clustering
 operation.</td></tr>
<tr><td width="4%"></td><td width="19%"><code>&quot;iter&quot;</code></td><td width="2%"></td><td width="75%">Display a summary for each iteration of a
 clustering operation.</td></tr>
</table>

 <table>
<thead><tr><th width="15%">Name</th><th width="2%"></th><th width="83%">Value</th></tr></thead>
<tr><td width="15%"><code>&quot;Replicates&quot;</code></td><td width="2%"></td><td width="83%">A positive integer specifying the number
 of independent clusterings to perform.  The output values are the values for
 the best clustering, i.e., the one with the smallest value of <var>sumd</var>.
 If <var>Start</var> is numeric, then <var>Replicates</var> defaults to
 (and must equal) the size of the third dimension of <var>Start</var>.
 Otherwise it defaults to 1.</td></tr>
<tr><td width="15%"><code>&quot;MaxIter&quot;</code></td><td width="2%"></td><td width="83%">The maximum number of iterations to perform
 for each replicate.  If the maximum change of any centroid is less than
 0.001, then the replicate terminates even if <var>MaxIter</var> iterations have no
 occurred.  The default is 100.</td></tr>
</table>

<p> Example:
</p>
<p> [~,c] = kmeans (rand(10, 3), 2, &quot;emptyaction&quot;, &quot;singleton&quot;);
</p>
<p> <strong>See also: </strong>
  <a href="linkage.html">linkage</a>
</p>
<p><strong>Source Code: </strong>
  <a href="https://github.com/gnu-octave/statistics/tree/main/inst/kmeans.m">kmeans</a>
</div>
        <div class="container-xl my-4">
          <div class="card rounded">
            <div class="card-header card-header-mod">
              <div class="row d-flex flex-wrap align-items-center">
                <div class="col-sm-3 col-md-5 mb-2 mb-sm-0">
                  <h3 class="d-inline-block mr-2">
                  Example: 1
                  </h3>
                </div>
              </div>
            </div>
            <div class="card-body">
              <div class="container bg-light">
                <div class="row">
                  <table><tbody><tr>
                    <td>&nbsp;</td>
                    <td><pre class="example">

 ## Generate a two-cluster problem

 C1 = randn (100, 2) + 1;
 C2 = randn (100, 2) - 1;
 data = [C1; C2];

 ## Perform clustering
 [idx, centers] = kmeans (data, 2);

 ## Plot the result
 figure;
 plot (data (idx==1, 1), data (idx==1, 2), "ro");
 hold on;
 plot (data (idx==2, 1), data (idx==2, 2), "bs");
 plot (centers (:, 1), centers (:, 2), "kv", "markersize", 10);
 hold off;

                    </pre></td></tr></tbody>
                  </table>
                  <div class="text-center">
                    <img src="assets/kmeans_101.png" class="rounded img-thumbnail" alt="plotted figure">
                  </div><p></p>

                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="container-xl my-4">
          <div class="card rounded">
            <div class="card-header card-header-mod">
              <div class="row d-flex flex-wrap align-items-center">
                <div class="col-sm-3 col-md-5 mb-2 mb-sm-0">
                  <h3 class="d-inline-block mr-2">
                  Example: 2
                  </h3>
                </div>
              </div>
            </div>
            <div class="card-body">
              <div class="container bg-light">
                <div class="row">
                  <table><tbody><tr>
                    <td>&nbsp;</td>
                    <td><pre class="example">

 ## Cluster data using k-means clustering, then plot the cluster regions.
 ## Load Fisher's iris data set and use the petal lengths and widths as
 ## predictors.

 load fisheriris
 X = meas(:,3:4);

 figure;
 plot (X(:,1), X(:,2), "k*", "MarkerSize", 5);
 title ("Fisher's Iris Data");
 xlabel ("Petal Lengths (cm)");
 ylabel ("Petal Widths (cm)");

 ## Cluster the data. Specify k = 3 clusters.
 [idx, C] = kmeans (X, 3);
 x1 = min (X(:,1)):0.01:max (X(:,1));
 x2 = min (X(:,2)):0.01:max (X(:,2));
 [x1G, x2G] = meshgrid (x1, x2);
 XGrid = [x1G(:), x2G(:)];

 idx2Region = kmeans (XGrid, 3, "MaxIter", 1, "Start", C);
 figure;
 gscatter (XGrid(:,1), XGrid(:,2), idx2Region, ...
           [0, 0.75, 0.75; 0.75, 0, 0.75; 0.75, 0.75, 0], "..");
 hold on;
 plot (X(:,1), X(:,2), "k*", "MarkerSize", 5);
 title ("Fisher's Iris Data");
 xlabel ("Petal Lengths (cm)");
 ylabel ("Petal Widths (cm)");
 legend ("Region 1", "Region 2", "Region 3", "Data", "Location", "SouthEast");
 hold off

warning: kmeans: failed to converge in 1 iterations
warning: called from
    kmeans at line 442 column 7
    build_DEMOS at line 94 column 11
    function_texi2html at line 286 column 14
    package_texi2html at line 278 column 7

                    </pre></td></tr></tbody>
                  </table>
                  <div class="text-center">
                    <img src="assets/kmeans_202.png" class="rounded img-thumbnail" alt="plotted figure">
                  </div><p></p>
                  <div class="text-center">
                    <img src="assets/kmeans_201.png" class="rounded img-thumbnail" alt="plotted figure">
                  </div><p></p>

                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="container-xl my-4">
          <div class="card rounded">
            <div class="card-header card-header-mod">
              <div class="row d-flex flex-wrap align-items-center">
                <div class="col-sm-3 col-md-5 mb-2 mb-sm-0">
                  <h3 class="d-inline-block mr-2">
                  Example: 3
                  </h3>
                </div>
              </div>
            </div>
            <div class="card-body">
              <div class="container bg-light">
                <div class="row">
                  <table><tbody><tr>
                    <td>&nbsp;</td>
                    <td><pre class="example">

 ## Partition Data into Two Clusters

 X = [randn(100,2)*0.75+ones(100,2); randn(100,2)*0.5-ones(100,2)];

 figure;
 plot (X(:,1), X(:,2), ".");
 title ("Randomly Generated Data");
 [idx, C] = kmeans (X, 2, "Distance", "cityblock", ...
                          "Replicates", 5, "Display", "final");
 figure;
 plot (X(idx==1,1), X(idx==1,2), "r.", "MarkerSize", 12);
 hold on
 plot(X(idx==2,1), X(idx==2,2), "b.", "MarkerSize", 12);
 plot (C(:,1), C(:,2), "kx", "MarkerSize", 15, "LineWidth", 3);
 legend ("Cluster 1", "Cluster 2", "Centroids", "Location", "NorthWest");
 title ("Cluster Assignments and Centroids");
 hold off

Replicate 1, 5 iterations, total sum of distances = 188.577.
Replicate 2, 4 iterations, total sum of distances = 188.577.
Replicate 3, 5 iterations, total sum of distances = 188.577.
Replicate 4, 5 iterations, total sum of distances = 188.577.
Replicate 5, 4 iterations, total sum of distances = 188.577.
Best total sum of distances = 188.577
                    </pre></td></tr></tbody>
                  </table>
                  <div class="text-center">
                    <img src="assets/kmeans_302.png" class="rounded img-thumbnail" alt="plotted figure">
                  </div><p></p>
                  <div class="text-center">
                    <img src="assets/kmeans_301.png" class="rounded img-thumbnail" alt="plotted figure">
                  </div><p></p>

                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="container-xl my-4">
          <div class="card rounded">
            <div class="card-header card-header-mod">
              <div class="row d-flex flex-wrap align-items-center">
                <div class="col-sm-3 col-md-5 mb-2 mb-sm-0">
                  <h3 class="d-inline-block mr-2">
                  Example: 4
                  </h3>
                </div>
              </div>
            </div>
            <div class="card-body">
              <div class="container bg-light">
                <div class="row">
                  <table><tbody><tr>
                    <td>&nbsp;</td>
                    <td><pre class="example">

 ## Assign New Data to Existing Clusters

 ## Generate a training data set using three distributions.
 X = [randn(100,2)*0.75+ones(100,2); ...
     randn(100,2)*0.5-ones(100,2); ...
     randn(100,2)*0.75];

 ## Partition the training data into three clusters by using kmeans.

 [idx,C] = kmeans(X,3);

 ## Plot the clusters and the cluster centroids.

 figure
 gscatter (X(:,1), X(:,2), idx, "bgm", "***");
 hold on
 plot(C(:,1),C(:,2),'kx');
 legend('Cluster 1','Cluster 2','Cluster 3','Cluster Centroid')

 ## Generate a test data set.
 Xtest = [randn(10,2)*0.75+ones(10,2); ...
          randn(10,2)*0.5-ones(10,2); ...
          randn(10,2)*0.75];
 ## Xlassify the test data set using the existing clusters.
 ## Find the nearest centroid from each test data point by using pdist2.

 D = pdist2 (C, Xtest, "euclidean");
 [group, ~] = find (D == min (D));

 ## Plot the test data and label the test data using idx_test with gscatter.

 gscatter (Xtest(:,1), Xtest(:,2), group, "bgm", "ooo");
 legend("Cluster 1", "Cluster 2", "Cluster 3", "Cluster Centroid", ...
        "Data classified to Cluster 1", "Data classified to Cluster 2", ...
        "Data classified to Cluster 3", "Location", "NorthWest");
 title ("Assign New Data to Existing Clusters");

                    </pre></td></tr></tbody>
                  </table>
                  <div class="text-center">
                    <img src="assets/kmeans_401.png" class="rounded img-thumbnail" alt="plotted figure">
                  </div><p></p>

                </div>
              </div>
            </div>
          </div>
        </div>


        </div>
      </div>
    </div>

  </body>
</html>
